import type { JournalEntry, JournalEntryType, TravelPlan, TripEvent } from "../types/domain";

interface JournalDraftResult {
  state: "ready" | "insufficient_data";
  text: string;
}

type JournalDraftComposer = (input: {
  dateLocal: string;
  planTitle: string;
  events: TripEvent[];
  photoCount: number;
  topLocationLabel: string | null;
  generateWithoutData: boolean;
}) => JournalDraftResult;

function pad2(value: number) {
  return String(value).padStart(2, "0");
}

function toDateParts(dateLocal: string) {
  const [year, month, day] = dateLocal.split("-").map(Number);
  return { year, month, day };
}

function dateRangeLocal(startDateLocal: string, endDateLocal: string) {
  const result: string[] = [];
  const start = toDateParts(startDateLocal);
  const end = toDateParts(endDateLocal);
  let cursorMs = Date.UTC(start.year, start.month - 1, start.day);
  const endMs = Date.UTC(end.year, end.month - 1, end.day);

  while (cursorMs <= endMs) {
    const date = new Date(cursorMs);
    result.push(`${date.getUTCFullYear()}-${pad2(date.getUTCMonth() + 1)}-${pad2(date.getUTCDate())}`);
    cursorMs += 24 * 60 * 60 * 1000;
  }
  return result;
}

function uniqueDateLocals(events: TripEvent[]) {
  return [...new Set(events.map((event) => event.dateLocal))].sort();
}

function inferType(events: TripEvent[]): JournalEntryType {
  const lead = events.find((event) => event.category !== null);
  if (!lead?.category) {
    return "etc";
  }
  return lead.category;
}

function estimatePhotoCount(events: TripEvent[]) {
  if (events.length === 0) {
    return 0;
  }
  const completedBonus = events.filter((event) => event.status === "completed").length;
  return Math.min(events.length * 2 + completedBonus, 12);
}

function inferTopLocation(events: TripEvent[]) {
  for (const event of events) {
    if (event.locationLabel) {
      return event.locationLabel;
    }
  }
  return null;
}

export function rebuildAutoJournals(
  plans: TravelPlan[],
  eventsByPlan: Record<string, TripEvent[]>,
  currentEntries: JournalEntry[],
  generateWithoutData: boolean,
  composeDraft: JournalDraftComposer
): JournalEntry[] {
  const manualEntries = currentEntries.filter((entry) => !entry.autoGenerated);
  const autoEntries: JournalEntry[] = [];

  for (const plan of plans) {
    if (plan.journalEnabledAtMs === null) {
      continue;
    }
    const planEvents = eventsByPlan[plan.id] ?? [];
    const targetDates = generateWithoutData
      ? dateRangeLocal(plan.startDateLocal, plan.endDateLocal)
      : uniqueDateLocals(planEvents);

    for (const dateLocal of targetDates) {
      const dayEvents = planEvents.filter((event) => event.dateLocal === dateLocal);
      const draft = composeDraft({
        dateLocal,
        planTitle: plan.title,
        events: dayEvents,
        photoCount: estimatePhotoCount(dayEvents),
        topLocationLabel: inferTopLocation(dayEvents),
        generateWithoutData
      });

      if (draft.state === "insufficient_data") {
        continue;
      }

      autoEntries.push({
        id: `jr-auto-${plan.id}-${dateLocal}`,
        planId: plan.id,
        dateLocal,
        type: inferType(dayEvents),
        text: draft.text,
        imageUri: estimatePhotoCount(dayEvents) > 0 ? `auto-photo://${plan.id}/${dateLocal}` : null,
        autoGenerated: true
      });
    }
  }

  return [...manualEntries, ...autoEntries].sort((a, b) => {
    if (a.dateLocal !== b.dateLocal) {
      return a.dateLocal.localeCompare(b.dateLocal);
    }
    return a.id.localeCompare(b.id);
  });
}
